<!doctype html>
<html lang="en">

<head>
    <link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css" />
    <link rel="stylesheet" href="node_modules/reveal.js/dist/theme/black.css" />
    <link rel="stylesheet" href="node_modules/highlight.js/styles/base16/gruvbox-dark-hard.css" />
    <link rel="stylesheet" href="src/theme/index.css" />
</head>

<body>
    <div class="reveal">
        <div class="slides">
            <section data-markdown>
                # Why would anyone need JavaScript generator functions?

                ---

                ## Pedantry

                ---

                ## Why would anyone _care_ about generator functions?

                ---

                1. What is a generator? <!-- .element: class="fragment" data-fragment-index="0" -->
                1. Efficient code <!-- .element: class="fragment" data-fragment-index="1" -->
                2. Impossible code <!-- .element: class="fragment" data-fragment-index="2" -->

                ---

                ## What is a generator function?

            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code data-line-numbers="1-14|1|5,10|12,13">function* myGeneratorFunction() {
    // We create some data
    const claim01 = 'Efficient code';
    console.log('Created some data. Yielding', claim01);
    yield claim01;

    // And another bit of data
    const claim02 = 'Impossible code';
    console.log('Created some data. Yielding', claim02);
    yield claim02;

    // The line below might not do what you think it does.
    return 42;
}
</code></pre>
            </section>
            <section data-markdown>
                ### What happens if we run this function?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
let generator = myGeneratorFunction();
            </code></pre>
            </section>
            <section data-markdown>
                ### It doesn't do anything

                ---

                ### A generator object
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>function runGenerator(generator) {
    let result;
    do {
        result = generator.next();
        console.log(result);
    } while (!result.done);
}
</code></pre>
            </section>
            <section data-markdown>
                ### So what?

                ---

                ### Like arrays, but more awkward

                ---

                ## Efficient code

                ---

                ### The Tim Tam Slam

                ---

                1. Select a single biscuit.
                2. Bite a small chunk from one corner, 2&ndash;5&thinsp;mm from the apex.
                3. Repeat the bite on the diagonally opposite corner.
                4. Insert one of the bitten corners into a hot beverage. (Milo is traditional, but coffee, tea, or hot
                chocolate is also acceptable).
                5. Place your lips over the opposite corner, and draw liquid through the biscuit as if it were a straw.
                6. As soon as liquid enters your mouth, immediately consume the entire biscuit. It’s important to do
                this quickly before it loses its structural integrity.
                7. Repeat until there are no more Tim Tams, or you feel physically ill.

                ---

                ```javascript
                const bittenBiscuit = biteArbitraryCorner(biscuit);
                const doubleBitten = biteOppositeCorner(bittenBiscuit);
                const biscuitInBeverage = insertIntoBeverage(doubleBitten);
                const unstableBiscuit = drawLiquid(biscuitInBeverage);
                const deliciousness = insertIntoMouth(unstableBiscuit);
                ```
            </section>
            <section data-background-iframe="/slam-animation.html" data-background-interactive>
            </section>
            <section data-markdown>
                ## But what if we have a whole packet of biscuits?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
// A naive approach
const MAX_BISCUIT_CONSUMPTION = 5;
biscuits
    .map(biteArbitraryCorner)
    .map(biteOppositeCorner)
    .map(insertIntoBeverage)
    .map(drawLiquid)
    .map(insertIntoMouth)
    .slice(0, MAX_BISCUIT_CONSUMPTION);
                </code></pre>
            </section>
            <section data-background-iframe="/slam-asplode.html" data-background-interactive>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
// A naive approach
const MAX_BISCUIT_CONSUMPTION = 5;
biscuits
    .map(biteArbitraryCorner)
    .map(biteOppositeCorner)
    .map(insertIntoBeverage)
    .map(drawLiquid)
    .map(insertIntoMouth)
    .slice(0, MAX_BISCUIT_CONSUMPTION);
                </code></pre>
            </section>
            <section data-markdown>
                ### How do we fix it?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
const map = (transform) => function*(iterable) {
    for (let item of iterable) {
        yield transform(item);
    }
}
                </code></pre>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
const take = (maxResults) => function* (iterable) {
    let count = 0;
    for (const item of iterable) {
      yield item;
      count += 1;
      if (count >= maxResults) return;
    }
}
                </code></pre>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
const pipe = (startValue, ...functions) => functions.reduce(
    (val, f) => f(val),
    startValue
);
                </code></pre>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>
pipe(biscuits,
    map(biteArbitraryCorner),
    map(biteOppositeCorner),
    map(insertIntoBeverage),
    map(drawLiquid),
    map(insertIntoMouth),
    take(MAX_BISCUIT_CONSUMPTION)
);
                </code></pre>
            </section>
            <section data-background-iframe="/slam-multiple.html" data-background-interactive></section>
            <section data-markdown>
                ### Why does that work?

                ---

                ### Generators are lazy

                ---

                ## Impossible code
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>function* naturalNumbers() {
    let i = 0;
    while (true) {
        yield i;
        i += 1;
    }
}</code></pre>
            </section>
            <section data-markdown>
                ### What if we were to filter that?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>const filter = (shouldKeep) => function* (iterable) {
    for (let item of iterable) {
        if (shouldKeep(item)) yield item;
    }
}</code></pre>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>const isEven = x => x % 2 === 0;</code></pre>
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const evens = filter(isEven)(naturalNumbers());</code></pre>
            </section>
            <section data-markdown>
                ### But, of course…
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const evens = map(x => x * 2)(naturalNumbers());</code></pre>
            </section>
            <section data-markdown>
                ### What could we build with that?

                * Fibonacci sequence
                * Triangular numbers
                * Prime numbers
            </section>
            <section data-markdown>
                ### Boring

                ---

                ### Pointless interview question

                ---

                ### Eight Queens

                ---

                Given an 8&times;8 chess board, find a way to place eight queens on the board
                safely. That is, place them such that no queen can attack any other queen.
            </section>
            <section data-background-iframe="/n-queens-solution.html" data-background-interactive>
            </section>
            <section data-background-iframe="/queen-attacks.html" data-background-interactive>
            </section>
            <section data-markdown>
                ### 4,426,165,368
            </section>
            <section data-background-iframe="/queen-column.html" data-background-interactive>
            </section>
            <section data-background-iframe="/queen-row.html" data-background-interactive>
            </section>
            <section data-background-iframe="/n-queens-animation.html" data-background-interactive></section>
            <section data-markdown>
                ### 4,426,165,368 &rightarrow; 16,777,216

                ---

                ### Let's write some code

                ---

                ### What if no solution exists?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>take(16777216)</code></pre>
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const possibleSolutions = take(16777216)(naturalNumbers())</code></pre>
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const possibleSolutions = (n) => take(n ** n)(naturalNumbers())</code></pre>
            </section>
            <section data-markdown>
                ### How do we convert an integer to something we can test?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>const natToArray = (n) => (x) => {
    const radix = Math.max(n, 2);
    return Uint8Array.from(
        x
        .toString(radix)
        .padStart(n, '0')
        .split('')
        .map((i) => parseInt(i, radix)),
    );
};</code></pre>
            </section>
            <section data-markdown>
                ### How do we check for a valid solution?

                ---

                1. Check for queens in the same row
                2. Check for queens on the same diagonal
                3. (We already ruled out queens in the same column)
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const noRepeats = (solution) => new Set(solution).size === solution.length;</code></pre>
            </section>
            <section data-markdown>
                ### What about the same diagonal?
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>// Check diagonals for single queen
// Note the position of x1 and y1
const attacksDiagonal = (y1, x1, solution) =>
    solution.some((y2, x2) => Math.abs(x1 - x2) == Math.abs(y1 - y2) && x1 !== x2 && y1 !== y2);
                  </code></pre>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>const isValidSolution = (solution) =>
    noRepeats(solution) && !solution.some(attacksDiagonal);</code></pre>
            </section>
            <section data-markdown>
                ### Two more things
            </section>
            <section data-markdown>
                1. We only want one solution; and
                2. An array representing a base-8 number is difficult to read.
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const head = (iterableIterator) => iterableIterator.next().value;</code></pre>
            </section>
            <section>
                <pre data-trim data-noescape
                    class="javascript"><code>const headOrElse = (fallback) => (iterableIterator) => iterableIterator.next().value ?? fallback;</code></pre>
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>// Use spread operator to convert from Uint8Array to regular untyped array.
const solutionToPoints = (solution) => [...solution].map((y, x) => [x, y]);</code></pre>
            </section>
            <section data-markdown>
                ### Putting it all together…
            </section>
            <section>
                <pre data-trim data-noescape class="javascript"><code>const queens = (n) =>
    pipe(
        naturalNumbers(),
        take(n ** n),
        map(natToArray(n)),
        filter(isValidSolution),
        headOrElse(Uint8Array.from([])),
        solutionToPoints,
    );</code></pre>
            </section>
            <section data-markdown>
                ### But, does it work?
            </section>
            <section data-background-iframe="/n-queens-animation.html" data-background-interactive>
            </section>
            <section data-markdown>
                ### But, that's just two silly examples. What's the point?

                ---

                ### The point is changing the way you think

                ---

                ## What else can generators do?

                ---

                * Emulate `async`/`await`;
                * Provide _cancellable_ async functions;
                * State machines

                ---

                ## Things to remember

                * Generators are _lazy_
                * Being lazy allows us to think about problems differently
                * We do far too little with generators, please explore
        </div>
    </div>
    <script type="module" src="src/presentation.ts"></script>
</body>

</html>